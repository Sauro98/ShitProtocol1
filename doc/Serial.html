<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="src/github-pandoc.css" type="text/css" />
</head>
<body>
<h1 id="protocollo-seriale">Protocollo seriale</h1>
<p>Qui viene descritto il protocollo seriale utilizzato da nodo centrale e raspberry per comunicare</p>
<h2 id="handshake">Handshake</h2>
<p>Per iniziare a scambiarsi messaggi i due dispositivi devono connettersi tramite una fase di hadshake a tre vie. I tre passaggi sono (cliccare sui nomi per vederne il valore):</p>
<ul>
<li><p>Il nodo manda il messaggio <a href="html/_serial_helpers_8h.html#af2b107897ec6379466d577636887dd77"><code>HANDSHAKE_MESSAGE</code></a> al raspberry</p></li>
<li><p>Il raspberry invia in risposta il messaggio <a href="html/_serial_helpers_8h.html#a41cfa53e3d2208d45867791946525692"><code>HANDSHAKE_VALID_RESPONSE</code></a> al nodo.</p></li>
<li><p>Il nodo risponde con un messaggio di <a href="html/_serial_helpers_8h.html#a60411330920102474867ae41d399e6eb"><code>HANDSHAKE_END_MESSAGE</code></a> per terminare l'handshake.</p></li>
</ul>
<p>Dato che, per ovvie ragioni, l'utente può chiudere e riaprire il programma di controllo sulla raspberry in qualsiasi momento, c'è bisogno che la raspberry possa inizializzare l'handshake. Per questo ad ogni avvio del programma di monitoraggio la raspberry invia al nodo un messaggio di <a href="html/_serial_helpers_8h.html#a89aebc7ab652f6641313788385c869a8"><code>HANDSHAKE_RESET</code></a>.</p>
<p>La raspberry cercherà il nodo nelle prome 20 porte e si fermerà se non lo trova. Se si è completamente certi che il nodo sia collegato ma il programma non lo rileva riavviare la raspberry.</p>
<h2 id="registrazione">Registrazione</h2>
<p>Quando l'utente dà al programma di controllo l'input per iniziare la registrazione di nuovi dispositivi la raspberry invia al nodo il messaggio <a href="html/_serial_helpers_8h.html#a99579e65eeab14ee81e13cf673263848"><code>MESSAGE_TYPE_ENTER_REGISTRATION_MODE</code></a>, al cui il nodo risponderà con lo stesso messaggio una volta che è pronto per iniziare la fase di registrazione.</p>
<p>Dopo che la raspberry ha ricevuto il messaggio di Ok dal nodo invia un pacchetto con header <a href="html/_serial_helpers_8h.html#ae2ce20aff2399a62ac34d4ef8d40a0d8"><code>MESSAGE_TYPE_DEVICES_COUNT</code></a> contenente il numero di dispositivi da registrare (valore inserito dall'utente).</p>
<p>A questo punto il nodo inizia la procedure di registrazione come descritta in <a href="WorkingProtocol.html">WorkingProtocol</a>. Durante questa fase il nodo invierà gli indirizzi temporanei dei nodi appena li riceve per verificare che non coincidano con altri già presenti nel database della raspberry. Per fare questo invia alla raspberry un pacchetto con header <a href="html/_serial_helpers_8h.html#ac2c4340003d1304446888ebd05f3c504"><code>MESSAGE_TYPE_ID_CHECK_REQUEST_RESPONSE</code></a>, contenente l'indirizzo del dispositivo. Dopo aver controllato nel suo database se l'indirizzo è un duplicato la raspberry rispode con un messaggio con lo stesso header ma con payload <a href="html/_serial_helpers_8h.html#a2cf28dfd8d82298695e6fc35b23d221d"><code>MESSAGE_ID_VALID</code></a> se l'indirizzo non è duplicato, <a href="html/_serial_helpers_8h.html#aa8a621e1a90c21af0eac0087ec1ee57e"><code>MESSAGE_ID_INVALID</code></a> altrimenti.</p>
<p>Dopo che il nodo ha riempito la sua coda di dispositivi da registrare inizia uno stream verso la raspberry in cui invierà gli indirizzi di tutti i dispositivi ed il loro tipo. Ogni pacchetto di questo stream ha come header <a href="html/_serial_helpers_8h.html#a251dda3cbcc1b5e35c461e46fff809c7"><code>MESSAGE_TYPE_DEVICES_SUBMISSION</code></a>. Per inizializzare lo stream il nodo invia il messaggio <a href="html/_serial_helpers_8h.html#a8a434e0d5e9502abcd0bdd269a0af6fe"><code>MESSAGE_DEVICES_STREAM_START</code></a>, al quale la raspberry si prepara alla ricezione ma non risponde.</p>
<p>Dopodichè, per ogni dispositivo, il nodo lo notifica dell'accettazione del suo indirizzo poi invia un pacchetto alla raspberry contenente indirizzo e codice del tipo, come da database nella raspberry.</p>
<p>Quando il nodo termina la sua lista invia il messaggio <a href="html/_serial_helpers_8h.html#a86cdfb354c21082bf33069b7e4385aed"><code>MESSAGE_DEVICES_STREAM_END</code></a> alla raspberry per segnalare la chiusura dello stream.</p>
<h2 id="funzione-a-regime">Funzione a regime</h2>
<p>Durante il normale funzionamento ci sono tre possibili casi in cui i due dispositivi comunicano via seriale:</p>
<h3 id="cambio-del-sensore-assegnato-ad-un-dispositivo">Cambio del sensore assegnato ad un dispositivo:</h3>
<p>Quandol'utente (tramite GUI) decice di cambiare il sensore assegnato ad un dispositivo il raspberry invia al nodo un messaggio con header <a href="html/_serial_helpers_8h.html#ae13d7df292a5f4fec58baff7ebbec5df"><code>MESSAGE_TYPE_SENSOR_SUBMISSION</code></a> contenente l'indirizzo del controllore e quello del nuovo sensore che deve ascoltare. Il nodo a questo punto invia l'informazione al controllore e comunica il risultato alla raspberry con un messaggio con <a href="html/_serial_helpers_8h.html#ac6ed920773b07537f61da599d432e006"><code>MESSAGE_TYPE_SEND_RESULT</code></a> come header e come body il risultato dell'operazione LoRa <a href="html/_lo_ra_protocol_8h.html#a3eea7170df892d921ffcbbfe1788cdaf"><code>sendPacket</code></a>.</p>
<h3 id="cambio-del-valore-di-luminosità-di-un-controllore">Cambio del valore di luminosità di un controllore</h3>
<p>Come sopra, solo che l'header del primo messaggio diventa <a href="html/_serial_helpers_8h.html#af04384d15b1b5d9fbe958609dc1e0887"><code>MESSAGE_TYPE_LIGHT_VALUE_CHANGED</code></a>.</p>
<h3 id="controllo-dello-stato">Controllo dello stato</h3>
<p>Come descritto in <a href="WorkingProtocol.html">WorkingProtocol</a> ogni 10 minuti la raspberry scorre il suo database di dispositivi per verificarne lo stato. Per ogni dispositivo (tranne il nodo ovviamente) invia al nodo un messaggio contenente l'indirizzo del dispositivo e avente come header <a href="html/_serial_helpers_8h.html#aa1bbc4e91c72a37d4c05d7536553f144"><code>MESSAGE_TYPE_CHECK_SENSOR_STATUS</code></a> se il dispositivo è un sensore oppure <a href="html/_serial_helpers_8h.html#a127fdcfc116c9366252705b060317f63"><code>MESSAGE_TYPE_CHECK_CONTROLLER_STATUS</code></a> altrimenti.</p>
<p>Alla ricezione di questo messaggio il nodo contatta il dispositivo richiesto e invia il risultato alla raspberry utlizzando il pacchetto <a href="html/_serial_helpers_8h.html#ac6ed920773b07537f61da599d432e006"><code>MESSAGE_TYPE_SEND_RESULT</code></a> contenente il valore del dimmer per i controllori, il valore della fotoresistenza per i sensori oppure <code>-1</code> se il dispositivo non è raggiungibile.</p>
<h2 id="aggiungere-nuovi-tipi-di-pacchetti">Aggiungere nuovi tipi di pacchetti</h2>
<p>Per aggiungere un nuovo tipo di pacchetto basta aggiungere il valore dell'header tra le costanti di <code>libsrc/SerialHelpers.h</code>, creare nello stesso file una funzione del tipo <code>is...Message(char databuffer[], int buffer_size)</code> che determina se un messaggio seriale ricevuto è del nuovo tipo ed una funzione <code>send...Message(...)</code> che invierà il messaggio in seriale. Per rispondere alla ricezione di tale messaggio sarà sufficiente aggiungere nella funzione <a href="https://www.arduino.cc/en/Reference/SerialEvent"><code>serialEnvent()</code></a> nel proprio programma arduino il codice:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">
    <span class="cf">if</span>(is...Message(serialMessage, serialMessageLength)){
        <span class="co">//do something</span>
    }</code></pre></div>
<p>Nel programma di gestione nella raspberry sarà invece sufficiente aggiungere un nuovo handler nel file <code>Raspberry-controller/src/serial/SerialHelpers.js</code> e connetterlo nella funzione <code>connectHandlers</code>.</p>
<p>Per poterlo ricevere aggiungere la funzione <code>is...Packet(data)</code> ed usarla nella funzione callPacketHandler inquesto modo:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">    <span class="cf">if</span>(is...Packet(data)){
        <span class="cf">return</span> ...Handler();
    }</code></pre></div>
</body>
</html>
